<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="LocalScript" referent="RBX5E882761E13F4E0F9CE1CB8DE3ED0E02">
		<Properties>
			<ProtectedString name="Source"><![CDATA[--[[

UI Particle System programmed by snowy like 6 months ago

MAKE SURE YOU ADD A "UIParticle" TAG TO THE PARTICLE PROXY INSTANCES OR ELSE THEY WON'T BE DETECTED BY THE SYSTEM

Removing the "UIParticle" tag from a particle proxy instance will stop it from emitting, but this can also be done by setting .Enabled to false

]]

--{{ Variables }}--

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local BaseParticleLabel = script:WaitForChild("Base",100)

local RNG = Random.new()
local insert = table.insert

local Particles = {}
local ActiveParticles = {}
local ActiveParticleEmissions = {}

--{{ Types }}--

type MappedNumberSequence = {
	{number}
}

type ParticleEmission = {
	-- INTERNAL PROPERTIES
	
	Owner: ParticleClass,
	Object: ImageLabel,
	StartTime: number,
	EndTime: number,
	BaseSize: UDim2,
	Position: {number},
	Rotation: number,
	
	-- CUSTOM PROPERTIES
	
	Lifetime: number,
	Velocity: Vector2,
	Drag: number,
	Acceleration: Vector2,
	RotationSpeed: number,
	Transparency: MappedNumberSequence,
	Color: ColorSequence,
	SizeScale: MappedNumberSequence,
}

type ParticleClass = {
	-- INTERNAL PROPERTIES
	
	Cs: {RBXScriptConnection},
	Object: BoolValue,
	Active: {[ParticleEmission]: boolean},
	NextEmissionTime: number,
	InternalRate: number,
	InternalEmissionAmount: number,
	
	-- CUSTOM PROPERTIES
	
	Attrs: {
		Acceleration: Vector2,
		Color: ColorSequence,
		EmissionVelocity: Vector2,
		Enabled: boolean,
		Lifetime: NumberRange,
		OriginEnd: UDim2,
		OriginStart: UDim2,
		Rate: number,
		Rotation: NumberRange,
		RotationSpeed: NumberRange,
		Size: UDim2,
		SizeScale: NumberSequence,
		Speed: NumberRange,
		SpreadAngle: number,
		Texture: string,
		Transparency: NumberSequence,
		ZIndex: number,
	},
	
	-- METHODS
	
	Clear: (self: ParticleClass)->(),
	Remove: (self: ParticleClass)->(),
	Instantiate: (self: ParticleClass)->(),
	Emit: (self: ParticleClass, Time: number)->(),
}

--{{ Functions }}--

local F = {}

function F.RandomBetweenMinAndMax(Min: number, Max: number)
	if Min == Max then return Min end
	if Min > Max then Min,Max = Max,Min end
	return RNG:NextNumber(Min,Max)
end

function F.RandomBetweenNumberRange(NR: NumberRange)
	return F.RandomBetweenMinAndMax(NR.Min,NR.Max)
end

function F.RandomBetweenUD2MinAndMax(Min: UDim2, Max: UDim2)
	local MinX,MaxX = Min.X,Max.X
	local MinY,MaxY = Min.Y,Max.Y
	--
	local Rnd = F.RandomBetweenMinAndMax
	--
	return UDim2.new(
		Rnd(MinX.Scale,MaxX.Scale),
		Rnd(MinX.Offset,MaxX.Offset),
		Rnd(MinY.Scale,MaxY.Scale),
		Rnd(MinY.Offset,MaxY.Offset)
	)
end

function F.MapNumberSequence(NS: NumberSequence)
	local Mapped = {}
	for Index,Keypoint in next,NS.Keypoints do
		local HE = Keypoint.Envelope / 2
		insert(Mapped,{Keypoint.Time,Keypoint.Value + F.RandomBetweenMinAndMax(-HE,HE)})
	end
	return Mapped
end

function F.EndParticleEmission(Emission: ParticleEmission)
	local Owner = Emission.Owner
	local Active = Owner.Active
	Active[Emission] = nil
	--
	local Object = Emission.Object
	if Object then
		Object:Destroy()
	end
	--
	ActiveParticleEmissions[Emission] = nil
	--
	table.clear(Emission)
end

function F.V2FromAngle(Angle: number)
	local Rad = math.rad(Angle-90)
	--
	return Vector2.new(math.cos(Rad),math.sin(Rad))
end

function F.V2Unit(V: Vector2)
	if V.Magnitude == 0 then return Vector2.zero end
	return V.Unit
end

function F.UDim2Scalar(UD: UDim2, Scale: number)
	local UX,UY = UD.X,UD.Y
	--
	local SX = UX.Scale * Scale
	local OX = UX.Offset * Scale
	local SY = UY.Scale * Scale
	local OY = UY.Offset * Scale
	--
	return UDim2.new(SX,OX,SY,OY)
end

function F.GetColorFromColorSequence(CS: ColorSequence,Time: number)
	local Keypoints = CS.Keypoints
	local Max = #Keypoints
	local K = 1
	local T = Time
	for i=1,Max do
		local X = Keypoints[i]
		local TI = X.Time
		if T == TI then return X.Value end
		if T > TI then
			K = i
		else
			break
		end
	end
	if K == Max then return Keypoints[Max].Value end
	local Lower = Keypoints[K]
	local Upper = Keypoints[K+1]
	local LT = Lower.Time
	return Lower.Value:Lerp(Upper.Value,(Time-LT)/(Upper.Time-LT))
end

local function Lerp(a,b,t)return a+(b-a)*t end

function F.GetNumberFromMappedNumberSequence(NS: MappedNumberSequence, Time: number)
	local Max = #NS
	local K = 1
	local T = Time
	for i=1,Max do
		local X = NS[i]
		local TI = X[1]
		if T == TI then return X[2] end
		if T > TI then
			K = i
		else
			break
		end
	end
	if K == Max then return NS[Max][2] end
	local Lower = NS[K]
	local Upper = NS[K+1]
	local LT = Lower[1]
	return Lerp(Lower[2],Upper[2],(Time-LT)/(Upper[1]-LT))
end

function F.FakeUDim2(UD: UDim2)
	local UX,UY = UD.X,UD.Y
	return {UX.Scale,UX.Offset,UY.Scale,UY.Offset}
end

function F.FakeUDim2ToUDim2(FUD: {number})
	return UDim2.new(unpack(FUD))
end

--{{ Particle Class }}--

local DefaultParticleAttributes = {
	Enabled = {
		Value = false,
		OnChanged = function(self: ParticleClass, Value)
			ActiveParticles[self] = if Value then true else nil
		end,
	},
	Acceleration = {
		Value = Vector2.zero,
	},
	Color = {
		Value = ColorSequence.new(Color3.new(1,1,1)),
	},
	EmissionVelocity = {
		Value = Vector2.new(0,-1),
	},
	Lifetime = {
		Value = NumberRange.new(1),
	},
	OriginEnd = {
		Value = UDim2.new(0,0,0,0),
	},
	OriginStart = {
		Value = UDim2.new(0,0,0,0),
	},
	Rate = {
		Value = 1,
		OnChanged = function(self: ParticleClass, Value)
			self.InternalRate = 1/Value
			self.InternalEmissionAmount = math.ceil(Value/60)
		end,
	},
	Rotation = {
		Value = NumberRange.new(0),
	},
	RotationSpeed = {
		Value = NumberRange.new(0),
	},
	Size = {
		Value = UDim2.new(0,0,0,0),
	},
	SizeScale = {
		Value = NumberSequence.new(1),
	},
	Speed = {
		Value = NumberRange.new(0),
	},
	SpreadAngle = {
		Value = 0,
	},
	Texture = {
		Value = "rbxassetid://15643534891",
	},
	Transparency = {
		Value = NumberSequence.new(1),
	},
	ZIndex = {
		Value = 1,
	},
	Clear = {
		Value = false,
		OnChanged = function(self: ParticleClass, Value)
			if Value then
				self:Clear()
				self.Object:SetAttribute("Clear",false)
			end
		end,
	},
	Drag = {
		Value = 0,
	},
}

local ParticleClass = {}
ParticleClass.__index = ParticleClass

function ParticleClass.Clear(self: ParticleClass)
	local End = F.EndParticleEmission
	for Emission,_ in next,self.Active do
		End(Emission)
	end
end

function ParticleClass:Remove()
	local Cs = self.Cs
	for K,V in next,Cs do
		V:Disconnect()
	end
	table.clear(Cs)
	--
	ActiveParticles[self] = nil
	self:Clear()
	--
	local Object = self.Object
	if Object then
		self.Object = nil
		Particles[Object] = nil
	end
	--
	setmetatable(self,nil)
end

function ParticleClass.Instantiate(self: ParticleClass)
	local Object = self.Object
	local Attrs = Object:GetAttributes()
	self.Attrs = Attrs
	local Cs = self.Cs
	--
	for Name,Data in next,DefaultParticleAttributes do
		local OnChanged = Data.OnChanged
		insert(Cs,Object:GetAttributeChangedSignal(Name):Connect(function()
			local Value = Object:GetAttribute(Name)
			Attrs[Name] = Value
			if OnChanged then
				OnChanged(self,Value)
			end
		end))
		local Value = Attrs[Name]
		if Value == nil then
			Value = Data.Value
			Attrs[Name] = Value
		end
		if OnChanged then
			OnChanged(self,Value)
		end
	end
	--
end

--{{ Particle Class Methods }}--

function ParticleClass.Emit(self: ParticleClass, Time: number)
	local Attrs = self.Attrs
	local Image = Instance.fromExisting(BaseParticleLabel)
	--
	local RndNR = F.RandomBetweenNumberRange
	local MapNS = F.MapNumberSequence
	--
	local Direction = F.V2Unit(Attrs.EmissionVelocity + F.V2FromAngle(F.RandomBetweenMinAndMax(0,Attrs.SpreadAngle)))
	local Speed = RndNR(Attrs.Speed)
	local Velocity = Direction * Speed
	--
	local Cache = {
		Owner = self,
		Object = Image,
		StartTime = Time,
		Lifetime = RndNR(Attrs.Lifetime),
		RotationSpeed = RndNR(Attrs.RotationSpeed),
		Velocity = Velocity,
		Acceleration = Attrs.Acceleration,
		Transparency = MapNS(Attrs.Transparency),
		Color = Attrs.Color,
		SizeScale = MapNS(Attrs.SizeScale),
		BaseSize = Attrs.Size,
		Position = F.FakeUDim2(F.RandomBetweenUD2MinAndMax(Attrs.OriginStart,Attrs.OriginEnd)),
		Rotation = RndNR(Attrs.Rotation),
		Drag = Attrs.Drag,
	}
	Cache.EndTime = Time+Cache.Lifetime
	--
	Image.Size = Attrs.Size
	Image.Position = F.FakeUDim2ToUDim2(Cache.Position)
	Image.Rotation = Cache.Rotation
	Image.Image = Attrs.Texture
	--
	Image.Parent = self.Object.Parent
	Image.ZIndex = self.Attrs.ZIndex
	--
	self.Active[Cache] = true
	ActiveParticleEmissions[Cache] = true
end

--{{ Setup }}--

local function UIParticleRemoved(Object: BoolValue)
	local Cache = Particles[Object]
	if Cache then
		Cache:Remove()
	end
end

local function UIParticleAdded(Object: BoolValue)
	if Particles[Object] then UIParticleRemoved(Object) end
	--
	local Cache = {
		Object = Object,
		Cs = {},
		Active = {},
		NextEmissionTime = 0,
		InternalRate = 1,
		InternalEmissionAmount = 1,
	}
	--
	setmetatable(Cache,ParticleClass)
	--
	Particles[Object] = Cache
	--
	Cache:Instantiate()
end

CollectionService:GetInstanceAddedSignal("UIParticle"):Connect(UIParticleAdded)
CollectionService:GetInstanceRemovedSignal("UIParticle"):Connect(UIParticleRemoved)

for _,Object in next,CollectionService:GetTagged("UIParticle") do
	UIParticleAdded(Object)
end

--{{ Loop }}--

local UD2Scalar = F.UDim2Scalar
local CFromCS = F.GetColorFromColorSequence
local NFromNS = F.GetNumberFromMappedNumberSequence
local FUD2ToUD2 = F.FakeUDim2ToUDim2
local V2Unit = F.V2Unit
local max = math.max

RunService:BindToRenderStep("UIParticleRender",94,function(Delta: number)
	local Time = tick()
	-- ACTIVE PARTICLES
	for Particle: ParticleClass,_ in next,ActiveParticles do
		if Time >= Particle.NextEmissionTime then
			Particle.NextEmissionTime = Time + Particle.InternalRate
			local EmissionAmount = Particle.InternalEmissionAmount
			for i=1,EmissionAmount do
				Particle:Emit(Time)
			end
		end
	end
	-- ACTIVE PARTICLE EMISSIONS
	for Active: ParticleEmission,_ in next,ActiveParticleEmissions do
		if Active.EndTime <= Time then
			F.EndParticleEmission(Active)
			continue
		end
		local Life = Active.Lifetime
		local Alpha = (Time - Active.StartTime) / Life
		local Object: ImageLabel = Active.Object
		--
		Object.ImageColor3 = CFromCS(Active.Color,Alpha)
		Object.ImageTransparency = NFromNS(Active.Transparency,Alpha)
		Object.Size = UD2Scalar(Active.BaseSize,NFromNS(Active.SizeScale,Alpha))
		--
		local Velocity = Active.Velocity
		local Acceleration = Active.Acceleration
		local RotationSpeed = Active.RotationSpeed
		--
		local DeltaDrag = max(1 - (Active.Drag * Delta),0)
		RotationSpeed *= DeltaDrag
		Velocity *= DeltaDrag
		Velocity += Acceleration * Delta
		--
		Active.RotationSpeed = RotationSpeed
		Active.Velocity = Velocity
		--
		local PositionChange = Velocity * Delta
		local AP = Active.Position
		AP[2] += PositionChange.X
		AP[4] += PositionChange.Y
		Active.Rotation += RotationSpeed * Delta
		--
		Object.Position = FUD2ToUD2(AP)
		Object.Rotation = Active.Rotation
	end
end)]]></ProtectedString>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{37936CE7-29FC-40C1-B029-D5AD77EF1A37}</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">UIParticles</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ImageLabel" referent="RBXA4A9FB812BD14CF097F753EEBB61D6C3">
			<Properties>
				<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
				<Color3 name="ImageColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<Vector2 name="ImageRectOffset">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<Vector2 name="ImageRectSize">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<float name="ImageTransparency">0</float>
				<token name="ResampleMode">0</token>
				<token name="ScaleType">0</token>
				<Rect2D name="SliceCenter">
					<min>
						<X>0</X>
						<Y>0</Y>
					</min>
					<max>
						<X>0</X>
						<Y>0</Y>
					</max>
				</Rect2D>
				<float name="SliceScale">1</float>
				<UDim2 name="TileSize">
					<XS>1</XS>
					<XO>0</XO>
					<YS>1</YS>
					<YO>0</YO>
				</UDim2>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0.5</X>
					<Y>0.5</Y>
				</Vector2>
				<token name="AutomaticSize">0</token>
				<Color3 name="BackgroundColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<float name="BackgroundTransparency">1</float>
				<Color3 name="BorderColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<token name="BorderMode">0</token>
				<int name="BorderSizePixel">0</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<bool name="Interactable">true</bool>
				<int name="LayoutOrder">0</int>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0</XS>
					<XO>0</XO>
					<YS>0</YS>
					<YO>0</YO>
				</UDim2>
				<float name="Rotation">0</float>
				<bool name="Selectable">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<int name="SelectionOrder">0</int>
				<UDim2 name="Size">
					<XS>0</XS>
					<XO>100</XO>
					<YS>0</YS>
					<YO>100</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<bool name="Visible">true</bool>
				<int name="ZIndex">1</int>
				<bool name="AutoLocalize">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Base</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBX6547616312A84B8DBEBC9712CE14ADC9">
			<Properties>
				<bool name="Value">false</bool>
				<BinaryString name="AttributesSerialize"><![CDATA[EgAAAAwAAABBY2NlbGVyYXRpb24QAAAAAAAAAAAFAAAAQ29sb3IZBQAAAAAAAAAAAAAAAACA
PwAAgD8AAIA/AAAAAAAAgD4AAIA/AAAAAAAAAAAAAAAAAAAAPwAAgD/493c/AAAAAAAAAAAA
AEA/gYCAPAAAgD8AAAAAAAAAAAAAgD8AAAAAiYgIPwAAgD8EAAAARHJhZwYAAAAAAADwPxAA
AABFbWlzc2lvblZlbG9jaXR5EAAAAAAAAIC/BwAAAEVuYWJsZWQDAQgAAABMaWZldGltZRsA
AEBAAABAQAkAAABPcmlnaW5FbmQKAACAPwAAAAAAAIA/AAAAAAsAAABPcmlnaW5TdGFydAoA
AAAAAAAAAAAAgD8AAAAABAAAAFJhdGUGAAAAAAAAEEAIAAAAUm90YXRpb24bAAAAAAAAAAAN
AAAAUm90YXRpb25TcGVlZBsAADTDAAA0QwQAAABTaXplCgAAAAAyAAAAAAAAADIAAAAJAAAA
U2l6ZVNjYWxlFwIAAAAAAAAAAAAAAAAAgD8AAAAAAACAPwAAgD8FAAAAU3BlZWQbAABIQwAA
lkMLAAAAU3ByZWFkQW5nbGUGAAAAAAAAOUAHAAAAVGV4dHVyZQIYAAAAcmJ4YXNzZXRpZDov
LzE1NjQzNTM0ODkxDAAAAFRyYW5zcGFyZW5jeRcDAAAAAAAAAAAAAAAAAIA/AAAAAM3MTD4A
AAAAAAAAAAAAgD8AAIA/BgAAAFpJbmRleAYAAAAAAADwPw==]]></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">TemplateParticle</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="Part" referent="RBX4C5AEDD01C8749399DA556004C707B13">
		<Properties>
			<token name="shape">2</token>
			<token name="formFactorRaw">1</token>
			<bool name="Anchored">false</bool>
			<bool name="AudioCanCollide">true</bool>
			<float name="BackParamA">-0.5</float>
			<float name="BackParamB">0.5</float>
			<token name="BackSurface">0</token>
			<token name="BackSurfaceInput">0</token>
			<float name="BottomParamA">-0.5</float>
			<float name="BottomParamB">0.5</float>
			<token name="BottomSurface">0</token>
			<token name="BottomSurfaceInput">0</token>
			<CoordinateFrame name="CFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="CanCollide">false</bool>
			<bool name="CanQuery">true</bool>
			<bool name="CanTouch">true</bool>
			<bool name="CastShadow">true</bool>
			<string name="CollisionGroup">Default</string>
			<int name="CollisionGroupId">0</int>
			<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
			<PhysicalProperties name="CustomPhysicalProperties">
				<CustomPhysics>false</CustomPhysics>
			</PhysicalProperties>
			<bool name="EnableFluidForces">true</bool>
			<float name="FrontParamA">-0.5</float>
			<float name="FrontParamB">0.5</float>
			<token name="FrontSurface">0</token>
			<token name="FrontSurfaceInput">0</token>
			<float name="LeftParamA">-0.5</float>
			<float name="LeftParamB">0.5</float>
			<token name="LeftSurface">0</token>
			<token name="LeftSurfaceInput">0</token>
			<bool name="Locked">false</bool>
			<bool name="Massless">false</bool>
			<token name="Material">256</token>
			<string name="MaterialVariantSerialized"></string>
			<CoordinateFrame name="PivotOffset">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<float name="Reflectance">0</float>
			<float name="RightParamA">-0.5</float>
			<float name="RightParamB">0.5</float>
			<token name="RightSurface">0</token>
			<token name="RightSurfaceInput">0</token>
			<int name="RootPriority">0</int>
			<Vector3 name="RotVelocity">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="TopParamA">-0.5</float>
			<float name="TopParamB">0.5</float>
			<token name="TopSurface">0</token>
			<token name="TopSurfaceInput">0</token>
			<float name="Transparency">1</float>
			<Vector3 name="Velocity">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<Vector3 name="size">
				<X>0.00100000005</X>
				<Y>0.00100000005</Y>
				<Z>0.00100000005</Z>
			</Vector3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">clicker</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ConeHandleAdornment" referent="RBX17AE175A8B874FC1A34270E2863923BC">
			<Properties>
				<float name="Height">0.25</float>
				<bool name="Hollow">false</bool>
				<float name="Radius">0.125</float>
				<token name="Shading">0</token>
				<token name="AdornCullingMode">0</token>
				<bool name="AlwaysOnTop">false</bool>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<Vector3 name="SizeRelativeOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int name="ZIndex">-1</int>
				<Ref name="Adornee">RBX4C5AEDD01C8749399DA556004C707B13</Ref>
				<Color3 name="Color3">
					<R>1</R>
					<G>1</G>
					<B>0</B>
				</Color3>
				<float name="Transparency">0</float>
				<bool name="Visible">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">cone</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>